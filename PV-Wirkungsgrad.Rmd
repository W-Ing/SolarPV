---
title: "PV - Wirkungsgrad"
output:
  html_notebook: default
  pdf_document: 
    toc: true
    number_sections: true
  html_document: 
  df_print: paged
  word_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Geladen werden die Daten, die von der PV-Anlage mit Hilfe des SMA-Portals gewonnen werden.
Ziel ist es, in der Tabelle _data_ alle Datensätze aus den SMA-Daten, ergänzt um Hilfsgrößen, zur Verfügung zu stellen.

Die Daten liegen in Dateien tageweise vor, beim Download werden diese von Hand benannt, sie enthalten Datensätze (Zeilen), die im 5-Minuten-Rhythmus erfasst wurden. Beim Einlesen werden sie zusammengefügt.

Die Datensätze enthalten die Größen

leistung.pv  ---  leistung.stp  ---  netzeinspeisung ---  netzbezug  --- batt_ladung  ---  batt_entladung ---  ladezustand

Die beiden ersten Werte sind identisch, deswegen wird "leistung.stp"" in der Folge sofort gelöscht. 


# Vorbereitungen #

### Laden der nötigen Bibliotheken. ###
```{r message=FALSE, warning=FALSE, paged.print=FALSE}
source("01-Bibliotheken-laden.R")
```

###Zur Auswertung werden einige Funktionen benötigt, die hier definiert werden. ###
```{r}
source("02-Funktionen-bilden.R")
```

### Einlesen der Dateien "Daten_dd_mm_yyyy.csv": ###
Alle Größen in der Einheit W, mit Ausnahme von 'ladezustand', dieser wird beim Lesen als Prozentsatz übergeben und anschließend auf $10000 = 100 \%$ normiert weil die Batterie eine Kapazität von annähernd $10 kWh$ besitzt kann dies auch als $Wh$ gelesen werden.
Die Zeilen müssen sortiert werden, weil die Dateien nicht in der korrekten zeitlichen Reihenfolge eingelesen werden.
```{r}
# Einlesen der Datenfiles-----notig: 02-Funktionen-bilden.R----------------------
source("03-Files-einlesen.R")
```

### Einige Spalten werden erzeugt, gelöscht, bearbeitet und z.B. neu normiert:###

a)  Die neue Spalte 'ct' zaehlt die Datenzeilen 
b)  Über 'ladezustand' laeuft eine Glaettungsfunktion, um einzelne Ausfaelle in den Messungen zu beseitigen.
c) 'day' und 'hour' werden aus der Variablen 'zeit' extrahiert und im Datumsformat "yyyy-mm-dd" bzw. als Zahl 0 - 23 gespeichert.
d) 'ladediff' wird als Differenz von Ladezustand zwischen dem aktuellen Zustand und dem vorangegangenen berechnet (Einheit Wh).
e) 'batt_ladung' und 'bat_entladung' werden von W in Wh umgerechnet (W in der Zeit 5 min, deswegen Division durch 12). Anm.: In der späteren Auswertung wird dies so interpretiert: Eine zur Zeit t erbrachte Leistung P führt zu einer el. Arbeit von $P\cdot 5 \mbox{min}$ im Zeitintervall $t \pm 2,5 \mbox{min}$

```{r}
# Ergaenzende Spaltenoperationen ----------------------------------------------
source("03-Spalten-bearbeiten.R")
```

#  Auswertungen # 

## Tägliche Minima und Maxima identifizieren  - optional ##

```{r message=FALSE, warning=FALSE, paged.print=FALSE}
# Minima und MAxima markieren frueher R_Min_Max_mark.R
 source("04_Auswertungen_Min_Max_tgl_Per.R")
#-----------------------------------------------------------------------------------
```
```{r message=FALSE, warning=FALSE, paged.print=FALSE}
# Minima und MAxima markieren frueher R_Min_Max_mark.R
 source("04_Auswertungen_Summ_Ent_Ladung_in_Tagesper.R")
```

## Perioden zwischen horizontalen Niveaus bilden - Neutrale Zyklen ##

Ein _neutraler Zyklus_ ist eine Lade-Entlade-Vorgang der von einem Ladezustand des Akkus ausgehend zu diesem zurückkehrt.
Für diese ist es sinnvoll, Wirkungsgrade als Verhältnis von Output zu Input zu bilden.

"level" legt die Höhe des Ausgangszustands fest, der als Basis für die Berechnung von Wirkungsgraden dient.
Ein solcher Zyklus kann jeweils über oder unter dem Ausgangslevel bleiben (später mit UP bzw. DOWN gekennzeichnet). 

### Bildung der Grundfunktionen

1. Initialisieren der Funktion "zyklus_daten_gen(xdata, l)" mit den Parametern xdata zur Übergabe der Daten und l zur Übergabe des Levels
        
        Erzeugt die Spalten, die einen Zyklus mit einem Zähler charakteriseren und dessen Länge zählen:
        zyklus --- len_of_zyklus

2. Initialisieren der Funktion "zyklus_summen_gen(xdata)"   mit dem Parameter  xdata zur Übergabe von data 

        Erzeugt die innerhalb eines Zyklus konstanten Werte: 
        max_level : max(ladezustand),
        min_level : min(ladezustand),
        hub_level : max_level - min_level,
        mit_level : (min_level+max_level)/2,
        durchsatz : hub_level/len_zyklus*12, Einheit  Wh zwischen Min und Max / Stunde
        signum    : Wenn max_level über dem vorgegebenen Level  "UP" sonst "DOWN"
        lev       : Der gewählte Level gespeichert in % im Hinblick auf die Verkettung der Daten zu mehreren Levels 
```{r include=FALSE}
# NEU_ Perioden zwischen horizontalen Niveaus identifizieren ALT :04_Auswertungen_gen_zu Zyklus mit Level.R
source("04_Zyklus_Daten_gen.R",local=TRUE)
#-----------------------------------------------------------------------------------
# Ladung und Entladung in jedem Zyklus addieren 04_Auswertungen_Summ_Ent_Ladung_in_Level_Halbper.R
source("04_Zyklus_Summen_gen.R")
#------------------------------------------------------------------------------------
source("04_Auswertungen_Proj_1_wert_pro_levelpd.R",local=TRUE, echo= TRUE,verbose = getOption("verbose"))
```


### Zusammenfassung dieses Vorgangs ###

Dazu wird folgende Funktion definiert

```{r}
zyklen_bilden <- function(xdata, x) {   # xdata =Datensatz, x Vorgabe eines Levels
  xdata = zyklus_daten_gen(xdata, x)
  xdata = zyklus_summen_gen(xdata,x)
  red_data = zyklus_reduzieren(xdata)
  return(red_data)
}

```

Sie gibt die Auswertung zurück mit jeweils einem Wert pro Zyklus.


## Strecken monotoner Entladung
```{r}
source("04_Auswertungen_Monotone_Entladung_finden.R")

```


```{r}
temp <- monoton_fall(data)
```


```{r}

```



# Graphische Auswertungen #
## Darstellung der Wirkungsgrade in Abhängigkeit von Durchsatz ##

Die maximale Energiedifferenz  zwischen höchsten und niedrigsten Wert im Speicher in einer Halbperiode dividiert durch die Dauer der Halbperiode wird als (Energie-)Durchsatz bezeichnet angegeben in Wh/h.
'lev' bezeichnet dem gewählten level dividiert durch 1000.


```{r message=FALSE, warning=FALSE, paged.print=FALSE}
#-------------------------------------------------------- 
# Auswertung der Zyklen

proj_level = zyklen_bilden(data, 7000)

proj_level <- proj_level %>% 
  filter(eta > 0 & eta <= 10000) %>% 
  filter(day >= "2017-11-01") 

proj_level %>% 
   ggplot(aes(x = durchsatz/1000, y = eta)) + 
   geom_point(aes(x = durchsatz/1000, y = eta, color=lev)) +
   geom_smooth(mapping = aes(x = durchsatz/1000, y = eta, linetype = signum ),method=lm, se =FALSE) +
   labs(
      x = "Durchsatz in kWh/h",
      y = "Wirkungsgrad * 10000",
      color = "Level in %" )+
   facet_wrap(~ signum)



```


Duch Wahl mehrerer Levelwerte erhält man folgende Darstellung 

```{r paged.print=FALSE}
some_levels <- c(3000, 4000, 5000, 6000, 7000, 8000)
proj_level <- tibble()
for ( level in some_levels) {          # zu jedem level den Datensatz auswerten und reduzieren auf einen Wert pro Periode
  proj_level <- rbind(proj_level, zyklen_bilden(data, level)) # ueber mehrere Level aufsammeln
}
proj_level %>% 
   filter(eta <= 10000 & eta  != 0) %>% 
   filter(day >= "2017-10-01") %>% 
   ggplot(aes(x = durchsatz/1000, y = eta)) + 
   geom_point(aes(x = durchsatz/1000, y = eta, color=lev)) +
   geom_smooth(mapping = aes(x = durchsatz/1000, y = eta, linetype = signum ),method=lm, se =FALSE) +
   labs(
      x = "Durchsatz in kWh/h",
      y = "Wirkungsgrad * 10000",
      color = "Level in %"
   )  +                                       #+
   #geom_line(mapping = aes(x = durchsatz, y = eta, linetype = signum )) #+
   facet_wrap(~ lev)
```



## Darstellung der Wirkungsgrade in Abhängigkeit von der Mitte der Halbperiode ##

```{r message=FALSE, paged.print=FALSE}
# --------------------------------------------------------------- Proj_Level_Eta_vs_mit_level.R
source("05_Grafik_Eta_vs_Mitte.R", print.eval=TRUE) 
```


### Das Gleiche mit Aufsammeln von Daten zu mehreren Levels ###

Wirkungsgrade eta=0 oder eta > 10000 werden ausgeblendet.

```{r}
some_levels <- c(1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000,5500, 6000,6500, 7000,7500, 8000, 8500, 9000)
proj_level <- tibble()
for (level in some_levels) {
   proj_level <- rbind(proj_level, zyklen_bilden(data,level))
}
proj_level %>% 
   filter(eta  != 0 & eta <= 10000) %>% 
   ggplot(aes(x = mit_level, y = eta)) + 
   geom_point(aes(x = mit_level, y = eta, color=lev)) +
   geom_smooth(mapping = aes(x = mit_level, y = eta, linetype = signum ), method=lm) #+
   #geom_line(mapping = aes(x = durchsatz, y = eta, linetype = signum )) +
   #facet_wrap(~ signum)
 


```

















































